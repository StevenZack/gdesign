# 系统设计
- [整体架构](#整体架构)
- [HTTP服务器层](#http服务器层)
- [UDP发现层](#udp发现层)
- [文件传输模块](#文件传输模块)
- [远程控制模块](#远程控制模块)
- [摄像头直播模块](#摄像头直播模块)

## 整体架构

整个系统是又两个部分组成：网络核心库、UI层。

为什么要这样设计呢？由于本系统的目标是要做到跨多个平台(Windows,Linux,Android,Mac等)，为了减轻开发和维护的负担，整个系统必须最大化地将通用的部分剥离出来，尽量做到一次编写，到处运行。

因为移动端(Android)和桌面端(Windows,Linux,Mac)的UI差异太大，所以无法实现UI层的共享。但是，网络核心库在各个操作系统中是通用的，可以共享。因为本系统对于UI界面没有太大的要求，所以网络核心库是整个系统编写过程中的重中之重！在完成网络核心库之后，再将网络核心库集成到各大操作系统的UI程序里面，通过一个事件回调接口(后面会在系统初始化里面详细讲解)来实现网络核心库与UI层的通信。这样就实现了系统的跨平台。

其中，网络核心库主要分为两大模块：HTTP服务器模块、UDP守护进程模块

## HTTP服务器层

整个系统在启动的时候，第一步就是启动一个HTTP服务器。

这个HTTP服务器承载着文件传输、剪切板复制、摄像头直播和控制指令发送等功能。也就是说，基本上所有的模块都是基于这个HTTP服务器来传输信息和数据的。

### __1.HTTP服务器初始化__

HTTP服务器启动之后第一件事情就是进行系统初始化操作。系统在初始化的时候，需要传入几个参数：事件回调接口、HTTP服务器所要监听的端口号、临时文件夹的路径还有文件接收路径。如果所传入的参数为空的话，则使用默认的值。

(1) 事件回调接口(EventHandler)

事件回调接口(EventHandler)，是核心网络库向UI层通信的媒介。

为什么要设计这样一个接口？
    
    在GUI编程中，不管是桌面端，还是移动端。整个UI的操作、显示和修改，都是在同一个线程里面的，我们把这个线程叫做UI线程。在UI线程之中，是不允许进行一些耗时的操作的，比如说：Socket监听，网络请求等。否则会出现程序的图形界面卡死的情况。
    所以，在本系统中，因为需要启动一个HTTP服务器，这个HTTP服务器是绝对不能在UI线程中启动的，必须要另起一个新的线程。那么问题就来了，如果这个HTTP服务器有什么状态变化的情况（比如：HTTP服务器收到一个上传过来的文件，收到控制指令等），如何去通知UI线程，并在图形界面之中显示出来呢？
    我们只能设计这样一个接口，在UI层实现接口中定义好的方法，然后当HTTP服务器出现状态变化的时候，只需要调用该接口对应的方法即可。

事件回调接口是一个接口(Interface)，定义在网络核心库之中。里面定义了一些事件的方法，但是没有实现他们。这些方法是需要由UI层来实现的。因为UI层各有不同，比如收到的消息如何显示？在Android上是显示一个AlertDialog，在Windows上则是弹出一个AlertWindow。所以这些事件回调的方法，必须是由不同的UI层自己去实现，无法共享。

事件回调接口中包含一下事件方法：
- 当收到剪切板的时候
- 当收到Web上传的文件的时候
- 当收到其他客户端上传来的文件夹的时候
- 当新的设备上线或者下线的时候
- 当收到远程控制指令的时候
- 存储键值对
- 获取键值对

为什么事件回调接口中还需要包含存储键值对、获取键值对两个方法？

    系统在初始化的时候需要读取配置文件，这些配置文件是以键值对的形式存储在设备之中的。然而，在不同的操作系统之中，存储配置信息的方式各有不同。比如，Windows是存储在AppData目录下的，Linux是存储在用户目录下的隐藏文件夹里面的，而在Android系统中，配置信息是存储在SharedPreferences之中的。所以，我们需要抽象出一个存储键值对方法，和一个获取键值对的方法，来让各大平台各自实现自己的存储过程即可。

(2) HTTP服务器监听的端口号

HTTP服务器要监听的端口号(Port)，是在启动HTTP服务器时的必要参数。他有自己的默认值，用户可以在设置界面里面更改端口号。但是，因为服务器一旦启动了，端口号就不能修改了，所以当用户在设置界面里面修改了端口号之后，必须重启整个系统才能使修改生效。

(3) 临时文件夹路径

临时文件夹路径(Temp Path)，该参数是为了防止Temp目录空间不足的情况出现(Linux下默认Temp目录存储空间大小为4G)，于是让用户可以自定义Temp目录位置。

(4) 文件接收路径

文件接收路径，是该参数是在启动HTTP服务器时的必要参数，他有自己的默认值，用户也可以对其进行修改。在整个系统之中，该参数是以一个共有变量的形式存储在内存之中的。也就是说，如果用户在设置界面里面修改了该参数，则不需要重启系统，即可使之生效。

## UDP守护进程

守护进程(Deamon)，是整个网络核心库的两大主要模块之一。主要的作用是进行同一局域网下的在线设备相互发现(后面会在“设备发现模型”部分详细讲解)。

### __1.守护进程初始化__

守护进程初始化，是在HTTP服务器初始化之后进行的。初始化的时候，只需要一个参数即可：操作系统的标识。

操作系统的标识，主要作用不过是让用户能够快速识别其他在线设备。

### __2.设备发现模型__

为什么需要“在线设备互相发现”这一功能？

	在同一局域网之中，当有多台设备同时开启了本系统时。用户可以进行一些更加高级的操作，比如：远程控制，向指定设备发送文件夹等。如果没有在线设备相互发现这一功能的话，用户需要自行查询每台机器的局域网IP地址，同时还要自己一个字一个字填写IP地址和端口号，况且IP地址和端口号的输入过程十分麻烦且耗时。
	为了解决这一问题，为了让用户能够无需输入在线设备的IP地址，用户唯一需要做的事情就是在所有在线设备列表里面选择自己想要的设备即可。所以我们增加了UDP守护进程，主要用于同一局域网下的在线设备互相发现。

在线设备发现模型的要求

- 当设备上线的时候，要广播通知所有局域网下的已有设备
- 当设备下线的时候，所有局域网下的其他设备也要实时更新在线设备列表
- 设备需要让所以同一局域网下的其他设备知道自己的状态(如：是否开启了接收控制指令的选项)
- 当设备的状态改变时，要实时地在其他设备的在线设备列表里面更新

设备发现模型

【图】

如图，本系统的设备发现模型包含三个部分：广播发现、心跳连接和一个状态获取HTTP接口。

(1).广播发现

广播发现部分，是整个设备发现模型的基础，也是实现整个模型的过程的第一步。当设备启动本系统的时候，UDP守护进程初始化，同时会向所在的局域网广播一条上线提醒消息。但是，消息之中并不会包含”上线“等复杂表示，该消息仅仅只包含一个信息：那就是本机的HTTP服务器端口号。也就是说，所谓的广播发现，不过是一个向局域网下的全部设备广播一下自己的HTTP服务器端口号的简单操作罢了。

为什么只包含一个HTTP服务器端口号？

	广播发现这一行为是整个设备模型的基础，但也仅仅只是基础而已，他不会包含太多的功能或者作用。在系统启动的时候，向局域网的所有设备广播自己的HTTP服务器端口号，当其他在线设备收到这一个UDP广播消息的时候，仅仅意味着：”当前局域网下的在线设备列表产生变化了，需要更新一下在线设备列表了！“。
	虽然仅仅只包含一个简单的HTTP服务器端口号，但它却像一个跳板，告诉其他设备：我的状态改变了(这里的状态不仅仅包括上线、下线，还有在用户开启或关闭了”接收控制指令“选项的时候，也属于状态变化的范畴，这个时候也会向局域网下的所有设备广播自己的HTTP服务器端口号。)，快利用你们收到的HTTP服务器端口号，在我的HTTP服务器上获取我的具体状态信息。

(2).心跳连接

在设备发现模型之中，为了满足“当设备下线的时候，所有局域网下的其他设备要实时更新自己的在线设备列表”这一要求，我们必须要让每一台设备直接都建立一个心跳连接，这个心跳连接不会进行任何数据的传输，他的唯一作用就是让其他的设备知道自己是在线的。如果这个心跳连接断开的话，就说明此设备已经离线了。通过这样一种方式，就实现了“当设备下线的时候，所有局域网下的其他设备要实时更新自己的在线设备列表”。

(3).状态获取HTTP接口

每一台设备都需要设置这样的一个状态获取HTTP接口。因为HTTP协议是无状态的，这个接口的作用很简单，不管是谁来访问这个接口，都会向访问者返回本设备的实时状态信息，返回之后则立即断开连接。

每当收到在线设备列表变更的消息的时候，每台设备都会访问所有设备的状态获取HTTP接口。如果无法访问，则说明该设备已经离线，如果能访问，则将返回来的设备实时状态信息覆盖原有的设备列表中的信息。

总结

在本系统中设计的这个设备发现模型，在设计模式上，完美的实现了分而治之的思想。将设备实时状态更新这一功能按照类型分给了三个部分：广播发现，心跳连接和状态获取HTTP接口。他们分别代表了三个角色：通知者，监视者和展示者。每一个角色自身的功能极其简单，但是三个角色合作起来，却又能正好完成一项复杂的工作。这也是我个人在Go语言的学习过程之中领悟到的：解耦。这样一来，就不会像其他的设备发现模型那样，出现无限的广播反弹的现象，而且又简单。正所谓：把一件简单的事情做复杂很容易，但是能把一件复杂的事情简化的人才是大师。

## 文件传输模块

整个文件传输模块由两部分组成：文件部分和剪切板部分

### 1.文件部分

在文件部分的数据结构设计上，每一个文件个体包含三个信息：文件名，文件的绝对路径和文件的ID。

为什么要设计文件ID这一信息？

	由于文件传输模块是建立在HTTP服务器之上的，所以，为了防止不同的文件在的URL下载地址出现冲突，URL不能以文件名作为标识，又因为文件路径包含的“/”符号与URL的分隔符冲突，所以也不能以文件路径作为文件URL的唯一表示。只能在每一个文件添加了之后，用一个随机生成的数字作为每一个分享出去的文件的唯一标识，这就是文件ID的由来。

文件部分包含四个HTTP页面或接口，分别是：

- 文件列表页面
- 文件下载接口
- 文件预览接口
- 文件上传接口

文件部分是文件传输模块的重要组成部分，其未来的发展方向还有很多，改进的方法也有很多，比如使用并行下载来提升文件传输的速度等。

### 2.剪切板部分

剪切板部分比较简单，同样是给予HTTP服务器的。主要包含两个共有变量，一个用于存储剪切板的内容，另一个用于存储剪切板开启的状态。

为什么需要剪切板部分？

	剪切板是人们日常使用手机的过程中最常用到的功能之一。比如平时大家在手机上复制一段文字，复制一个网址，想要传给电脑怎么办呢？以前的办法是通过QQ或者微信发送给电脑端，然后电脑端再复制一下。这样有两个缺点：一个是电脑必须联网，另一个是电脑还必须安装QQ或者微信的客户端，如果说还有什么缺点的话，我认为应该是二次操作。所谓的二次操作是指手机复制了一次剪切板，发送到电脑上之后，电脑还得再复制一次。很不方便。所以我决定在本系统之中加入剪切板功能，就是为了方便大家在家具智能设备之间共享剪切板。


## 远程控制模块

远程控制模块包括控制者和被控制者。目前的版本，控制者只能是手机，被控制者只能是电脑。

控制者

控制者通过发送将控制指令以HTTP请求的方式发送给被控制者

被控制者

被控制者通过在HTTP服务器上新增一个接口，专门用于接收HTTP控制指令。当收到HTTP控制指令的时候，再又UI层去解析并执行控制指令

权限问题

被控制者默认是不接受任何控制指令的，这个时候如果有控制者想发送控制指令过来，会返回无效信息。只有当被控制者开启受控端选项的时候，才会接收控制指令。在“受控端”开启的时候，有两种选项：第一种是接收任何人的控制指令，第二种是接收指定设备的控制指令，第三种是接收除了指定设备以外的所有控制指令。

申请控制权限的过程

如果控制者是在受控端的可控设备列表之外的话，需要先向受控端申请控制权限，受控端同意了之后，才能进行远程控制。

## 摄像头直播模块

摄像头直播模块是基于HTTP服务器的，主要由广播，WebSocket长连接，直播者页面和观看者页面组成。

(1).WebSocket长连接

WebSocket长连接是将所有观看者和直播者通过HTTP服务器连接起来的媒介。之所以选择WebSocket是因为这是目前最新的Web技术————HTML5推荐的保持长连接的方法。摄像头直播时的广播就是依靠这一长连接来实现的。

(2).广播

广播是在HTTP服务器收到直播者在Web浏览器上发过来的摄像头数据的时候，将这一数据由服务器向所有在线的观看者发送过去的行为。

没当有新的用户连接到摄像头直播页面，就会与服务器建立一个WebSocket连接，同时，将该连接加入所有已连接的数组里面。这样一来，当直播者需要广播数据的时候，只需要遍历一下这个数组，然后逐一发送即可。

(3).直播者页面和观看者页面

直播者页面和观看者页面是由HTML5技术实现的，通过调用HTML5浏览器接口，获取摄像头数据，然后通过WebSocket发送给服务器，在观看者收到摄像头数据之后，利用Canvas画布显示出来即可。